<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: 2º Exercício | &lt;em&gt;Message Broker&lt;/em&gt;</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">2º Exercício | <em>Message Broker</em> </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>O segundo exercício do projeto pretende construir um sistema simples de publicação e subscrição de mensagens, que são armazenadas no sistema de ficheiros TecnicoFS. O sistema vai ter um processo servidor autónomo, ao qual diferentes processos clientes se podem ligar, para publicar ou receber mensagens numa dada caixa de armazenamento de mensagens.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Ponto de partida</h1>
<p>Para resolver o segundo exercício, os grupos devem usar como base a sua solução do 1º exercício ou <a href="https://github.com/tecnico-so/projeto-so-2022-23/">aceder ao novo código base</a>, que estende a versão original do TecnicoFS das seguintes maneiras:</p>
<ul>
<li>As operações principais do TecnicoFS estão sincronizadas usando um único trinco (<em>mutex</em>) global. Embora menos paralela que a solução pretendida para o primeiro exercício, esta solução de sincronização é suficiente para implementar os novos requisitos;</li>
<li>É implementado a operação <code>tfs_unlink</code>, que permite remover ficheiros.</li>
</ul>
<p>Adicionalmente, o código base inclui esqueletos para:</p>
<ol type="1">
<li>O programa do servidor <em>mbroker</em> (na diretoria <code>mbroker</code>);</li>
<li>A implementação do cliente para publicação (na diretoria <code>publisher</code>);</li>
<li>A implementação do cliente para subscrição (na diretoria <code>subscriber</code>);</li>
<li>A implementação do cliente de gestão (directoria <code>manager</code>).</li>
</ol>
<p>Em vez do novo código base, os grupos que tenham uma solução robusta no 1º exercício são encorajados a construírem a solução com base na sua versão, que à partida estará mais otimizada em termos de concorrência.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
1. Arquitetura do sistema</h1>
<p>O sistema é formado pelo servidor (<em>mbroker</em>) e por vários publicadores (<em>publishers</em>), subscritores (<em>subscribers</em>) e gestores (<em>manager</em>).</p>
<h2><a class="anchor" id="autotoc_md3"></a>
Caixas de Mensagens</h2>
<p>Um conceito fundamental do sistema são as caixas de mensagens. Cada caixa pode ter um publicador e múltiplos subscritores. O <em>publisher</em> coloca mensagens na caixa, e os vários <em>subscribers</em> lêem as mensagens da caixa. Cada caixa é suportada no servidor por um ficheiro no TFS. Por esta razão, o ciclo de vida de uma caixa é distinto do ciclo de vida do <em>publisher</em> que lá publica mensagens. Aliás, é possível que uma caixa venha a ter vários <em>publishers</em> ao longo da sua existência, embora apenas um de cada vez.</p>
<p>As operações de criação e remoção de caixa são geridas pelo <em>manager</em>. Adicionalmente, o <em>manager</em> permite listar as caixas existentes na <em>mbroker</em>.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
1.1. Servidor</h2>
<p>O servidor incorpora o TecnicoFS e é um processo autónomo, inicializado da seguinte forma:</p>
<div class="fragment"><div class="line">$ mbroker &lt;pipename&gt; &lt;max_sessions&gt;</div>
</div><!-- fragment --><p>O servidor cria um <em>named pipe</em> cujo nome (<em>pipename</em>) é o indicado no argumento acima. É através deste <em>named pipe</em>, criado pelo servidor, que os processos cliente se poderão ligar para se registarem.</p>
<p>Qualquer processo cliente pode ligar-se ao <em>named pipe</em> do servidor e enviar-lhe uma mensagem a solicitar o início de uma sessão. Uma <b>sessão</b> consiste em ter um <em>named pipe</em> do cliente, onde o cliente envia as mensagens (se for um publicador) ou onde o cliente recebe mensagens (se for um subscritor). Um dado cliente apenas assume um dos dois papéis, ou seja, ou é exclusivamente publicador e só envia informação para o servidor, ou é exclusivamente subscritor (ou gestor) e só recebe informação.</p>
<p>O <em>named pipe</em> da sessão deve ser criado previamente pelo cliente. Na mensagem de registo, o cliente envia o nome do <em>named pipe</em> a usar durante a sessão.</p>
<p>Uma sessão mantém-se aberta até que aconteça uma das seguintes situações:</p>
<ol type="1">
<li>Um cliente (publicador ou subscritor) feche o seu <em>named pipe</em>, sinalizando implicitamente o fim de sessão;</li>
<li>A caixa é removida pelo gestor.</li>
</ol>
<p>O servidor aceita um número máximo de sessões em simultâneo, definido pelo valor do argumento <code>max_sessions</code>.</p>
<p>Nas subsecções seguintes descrevemos o protocolo cliente-servidor em maior detalhe, i.e., o conteúdo das mensagens de pedido e resposta trocadas entre clientes e servidor.</p>
<h3><a class="anchor" id="autotoc_md5"></a>
1.1.1. Arquitectura do servidor</h3>
<p>O servidor deve ter uma <em>thread</em> para gerir o <em>named pipe</em> de registo e lançar <code>max_sessions</code> threads para processar sessões. Quando chega um novo pedido de registo, este deve ser enviado para uma <em>thread</em> que se encontre disponível, que irá processá-lo durante o tempo necessário. Para gerir estes pedidos, evitando que as <em>threads</em> fiquem em espera ativa, a <em>main thread</em> e as <em>worker threads</em> cooperam utilizando uma <b>fila produtor-consumidor</b>, segundo a interface disponibilizada no ficheiro <code>producer-consumer.h</code>. Desta forma, quando chega um novo pedido de registo, este é colocado na fila e assim que uma <em>thread</em> fique disponível, irá consumir e tratar esse pedido.</p>
<p>A arquitetura do servidor está sumarizada na seguinte figura:</p>
<p><img src="img/architecture_proj2.png" alt="" class="inline"/></p>
<ul>
<li>O <em>mbroker</em> usa o TFS para armazenar as mensagens das caixas;</li>
<li>A <em>main thread</em> recebe pedidos através do <em>register pipe</em> e coloca-os numa fila de produtor-consumidor;</li>
<li>As <em>worker threads</em> executam os pedidos dos clientes, dedicando-se a atender um cliente de cada vez;</li>
<li>Cooperam com a <em>main thread</em> através de uma fila produtor-consumidor, que evita espera ativa.</li>
</ul>
<h2><a class="anchor" id="autotoc_md6"></a>
1.2. &lt;em&gt;Publisher&lt;/em&gt;</h2>
<p>Um publicador é um processo lançado da seguinte forma:</p>
<div class="fragment"><div class="line">pub &lt;register_pipe&gt; &lt;pipe_name&gt; &lt;box_name&gt;</div>
</div><!-- fragment --><p>Assim que é lançado, o <em>publisher</em>, pede para iniciar uma sessão no servidor de <em>mbroker</em>, indicando a caixa de mensagens para a qual pretende escrever mensagens. Se a ligação for aceite (pode ser rejeitada caso já haja um <em>publisher</em> ligado à caixa, por exemplo) fica a receber mensagens do <code>stdin</code> e depois publica-as. Uma <b>mensagem</b> corresponde a uma linha do <code>stdin</code>, sendo truncada a um dado valor máximo e delimitada por um <code>\0</code>, como uma <em>string</em> de C. A mensagem não deve incluir um <code>\n</code> final.</p>
<p>Se o <em>publisher</em> receber um EOF (<em>End Of File</em>, por exemplo, com um Ctrl-D), deve encerrar a sessão fechando o <em>named pipe</em>.</p>
<p>O nome do <em>named pipe</em> da sessão é escolhido automaticamente pelo <em>publisher</em>, de forma a garantir que não existem conflitos com outros clientes concorrentes. O <em>named pipe</em> deve ser removido do sistema de ficheiros após o fim da sessão.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
1.3. &lt;em&gt;Subscriber&lt;/em&gt;</h2>
<p>Um subscritor é um processo lançado da seguinte forma:</p>
<div class="fragment"><div class="line">sub &lt;register_pipe&gt; &lt;pipe_name&gt; &lt;box_name&gt;</div>
</div><!-- fragment --><p>Assim que é lançado, o <em>subscriber</em>:</p>
<ol type="1">
<li>Liga-se à <em>mbroker</em>, indicando qual a caixa de mensagens que pretende subscrever;</li>
<li>Recolhe as mensagens já aí armazenadas e imprime-as uma a uma no <code>stdout</code>, delimitadas por <code>\n</code>;</li>
<li>Fica à escuta de novas mensagens;</li>
<li>Imprime novas mensagens quando são escritas para o <em>named pipe</em> para o qual tem uma sessão aberta.</li>
</ol>
<p>Para terminar o <em>subscriber</em>, este deve processar adequadamente o <code>SIGINT</code> (i.e., o Ctrl-C), fechando a sessão e imprimindo no <code>stdout</code> o número de mensagens recebidas durante a sessão.</p>
<p>O nome do <em>named pipe</em> da sessão é escolhido automaticamente pelo <em>subscriber</em>, de forma a garantir que não existem conflitos com outros clientes concorrentes. O <em>named pipe</em> deve ser removido do sistema de ficheiros após o fim da sessão.</p>
<h2><a class="anchor" id="autotoc_md8"></a>
1.4. &lt;em&gt;Manager&lt;/em&gt;</h2>
<p>Um gestor é um processo lançado de uma das seguintes formas:</p>
<div class="fragment"><div class="line">manager &lt;register_pipe&gt; &lt;pipe_name&gt; create &lt;box_name&gt;</div>
<div class="line">manager &lt;register_pipe&gt; &lt;pipe_name&gt; remove &lt;box_name&gt;</div>
<div class="line">manager &lt;register_pipe&gt; &lt;pipe_name&gt; list</div>
</div><!-- fragment --><p>Assim que é lançado, o <em>manager</em>:</p>
<ol type="1">
<li>Envia o pedido à <em>mbroker</em>;</li>
<li>Recebe a resposta no <em>named pipe</em> criado pelo próprio <em>manager</em>;</li>
<li>Imprime a resposta e termina.</li>
</ol>
<p>O nome do <em>named pipe</em> da sessão é escolhido automaticamente pelo <em>manager</em>, de forma a garantir que não existem conflitos com outros clientes concorrentes. O <em>named pipe</em> deve ser removido do sistema de ficheiros antes do <em>manager</em> terminar.</p>
<h2><a class="anchor" id="autotoc_md9"></a>
1.5. Exemplos de execução</h2>
<p>Um primeiro <b>exemplo</b> considera o funcionamento <b>sequencial</b> dos clientes:</p>
<ol type="1">
<li>Um <em>manager</em> cria a caixa <code>bla</code>;</li>
<li>Um <em>publisher</em> liga-se à mesma caixa, escreve 3 mensagens e desliga-se;</li>
<li>Um <em>subscriber</em> liga-se à mesma caixa e começa a receber mensagens;</li>
<li>Recebe as três, uma de cada vez, e depois fica à espera de mais mensagens.</li>
</ol>
<p>Num segundo <b>exemplo</b>, mais interessante, vai existir <b>concorrência</b> entre clientes:</p>
<ol type="1">
<li>Um <em>publisher</em> liga-se;</li>
<li>Entretanto, um <em>subscriber</em> para a mesma caixa, liga-se também;</li>
<li>O <em>publisher</em> coloca mensagens na caixa e estas vão sendo entregues imediatamente ao <em>subscriber</em>, ficando à mesma registadas no ficheiro;</li>
<li>Um outro <em>subscriber</em> liga-se à mesma caixa, e começa a receber as mensagens todas desde o início da sua subscrição;</li>
<li>Agora, quando o <em>publisher</em> escreve uma nova mensagem, ambos os <em>subscriber</em> recebem a mensagem diretamente.</li>
</ol>
<h1><a class="anchor" id="autotoc_md10"></a>
2. Protocolo</h1>
<p>Para moderar a interação entre o servidor e os clientes, é estabelecido um protocolo, que define como é que as mensagens são serializadas, ou seja, como é que ficam arrumadas num <em>buffer</em> de <em>bytes</em>. Este tipo de protocolo é por vezes referido como um <em>wire protocol</em>, numa alusão aos dados que efetivamente circulam no meio de transmissão, que neste caso, serão os <em>named pipes</em>.</p>
<p>O conteúdo de cada mensagem deve seguir o seguinte formato, onde:</p>
<ul>
<li>O símbolo <code>|</code> denota a concatenação de elementos numa mensagem;</li>
<li>Todas as mensagens de pedido são iniciadas por um código que identifica a operação solicitada (<code>OP_CODE</code>);</li>
<li>As <em>strings</em> que transportam os nomes de <em>named pipes</em> são de tamanho fixo, indicado na mensagem. No caso de nomes de tamanho inferior, os caracteres adicionais devem ser preenchidos com <code>\0</code>.</li>
</ul>
<h2><a class="anchor" id="autotoc_md11"></a>
2.1. Registo</h2>
<p>O <em>named pipe</em> do servidor, que só recebe registos de novos clientes, deve receber mensagens do seguinte tipo:</p>
<p>Pedido de registo de <em>publisher</em>:</p>
<div class="fragment"><div class="line">[ code = 1 (uint8_t) ] | [ client_named_pipe_path (char[256]) ] | [ box_name (char[32]) ]</div>
</div><!-- fragment --><p>Pedido de registo de <em>subscriber</em>:</p>
<div class="fragment"><div class="line">[ code = 2 (uint8_t) ] | [ client_named_pipe_path (char[256]) ] | [ box_name (char[32]) ]</div>
</div><!-- fragment --><p>Pedido de criação de caixa:</p>
<div class="fragment"><div class="line">[ code = 3 (uint8_t) ] | [ client_named_pipe_path (char[256]) ] | [ box_name (char[32]) ]</div>
</div><!-- fragment --><p>Resposta ao pedido de criação de caixa:</p>
<div class="fragment"><div class="line">[ code = 4 (uint8_t) ] | [ return_code (int32_t) ] | [ error message (char[1024]) ]</div>
</div><!-- fragment --><p>O return code deve ser <code>0</code> se a caixa foi criada com sucesso, e <code>-1</code> em caso de erro. Em caso de erro a mensagem de erro é enviada (caso contrário, fica simplesmente inicializada com <code>\0</code>).</p>
<p>Pedido de remoção de caixa:</p>
<div class="fragment"><div class="line">[ code = 5 (uint8_t) ] | [ client_named_pipe_path (char[256]) ] | [ box_name (char[32]) ]</div>
</div><!-- fragment --><p>Resposta ao pedido de remoção de caixa:</p>
<div class="fragment"><div class="line">[ code = 6 (uint8_t) ] | [ return_code (int32_t) ] | [ error message (char[1024]) ]</div>
</div><!-- fragment --><p>Pedido de listagem de caixas:</p>
<div class="fragment"><div class="line">[ code = 7 (uint8_t) ] | [ client_named_pipe_path (char[256]) ]</div>
</div><!-- fragment --><p>A resposta à listagem de caixas vem em várias mensagens, do seguinte tipo:</p>
<div class="fragment"><div class="line">[ code = 8 (uint8_t) ] | [ last (uint8_t) ] | [ box_name (char[32]) ] | [ box_size (uint64_t) ] | [ n_publishers (uint64_t) ] | [ n_subscribers (uint64_t) ]</div>
</div><!-- fragment --><p>O byte <code>last</code> é <code>1</code> se esta for a última caixa da listagem e a <code>0</code> em caso contrário. <code>box_size</code> é o tamanho (em <em>bytes</em>) da caixa, com <code>n_publisher</code> (<code>0</code> ou <code>1</code>) indicando se existe um <em>publisher</em> ligado à caixa naquele momento, e <code>n_subscriber</code> o número de subscritores da caixa naquele momento.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
2.2 &lt;em&gt;Publisher&lt;/em&gt;</h2>
<p>O <em>publisher</em> envia mensagens para o servidor do tipo:</p>
<div class="fragment"><div class="line">[ code = 9 (uint8_t) ] | [ message (char[1024]) ]</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md13"></a>
2.3 &lt;em&gt;Subscriber&lt;/em&gt;</h2>
<p>O servidor envia mensagens para o <em>subscriber</em> do tipo:</p>
<div class="fragment"><div class="line">[ code = 10 (uint8_t) ] | [ message (char[1024]) ]</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md14"></a>
3. Requisitos de implementação</h1>
<h2><a class="anchor" id="autotoc_md15"></a>
3.1. Tratamento de clientes</h2>
<p>Quando o servidor inicia, lança um conjunto de <code>S</code> tarefas (<em>thread pool</em>), que ficam à espera de pedidos de registo para tratar, que irão receber através da fila produtor-consumidor. A <em>main thread</em> gere o <em>named pipe</em> de registo, e coloca os pedidos de registo na fila produtor-consumidor. Quando uma <em>thread</em> termina uma sessão, fica à espera de nova sessão para tratar.</p>
<h2><a class="anchor" id="autotoc_md16"></a>
3.2 Caixas de armazenamento</h2>
<p>As mensagens recebidas pelo servidor devem ser colocadas numa caixa. Na prática, uma caixa corresponde a um ficheiro no TecnicoFS. O ficheiro deve ser criado quando a caixa for criada pelo <em>manager</em>, e apagado quando a caixa for removida. Todas as mensagens que vão sendo recebidas são escritas no fim do ficheiro, separadas por <code>\0</code>.</p>
<p>Resumindo, as mensagens são acumuladas nas caixas. Quando um subscritor se liga a uma caixa, o ficheiro correspondente é aberto e as mensagens começam a ser lidas desde o início (mesmo que o mesmo subscritor ou outro já as tenha recebido antes). Ulteriores mensagens geradas pelo <em>publisher</em> de uma caixa deverão ser também entregues aos <em>subscribers</em> da caixa. Esta funcionalidade deverá ser implementada usando <b>variáveis de condição</b> com o objetivo de evitar esperas ativas.</p>
<h2><a class="anchor" id="autotoc_md17"></a>
3.3 Formatação de mensagens</h2>
<p>Para uniformizar o <em>output</em> dos diversos comandos (para o <code>stdout</code>), é fornecido o formato com que estas devem ser impressas.</p>
<h2><a class="anchor" id="autotoc_md18"></a>
3.4 Fila Produtor-Consumidor</h2>
<p>A fila produtor-consumidor é a estrutura de sincronização mais complexa do projeto. Por isso, esta componente vai ser avaliada em isolamento (i.e., existirão testes que usam apenas a interface descrita no <code>producer-consumer.h</code>) para garantir a sua correção. Como tal, a interface do <code>producer-consumer.h</code> não deve ser alterada.</p>
<p>De resto, os grupos são livres de alterar o código base como lhes for conveniente.</p>
<h3><a class="anchor" id="autotoc_md19"></a>
Mensagens do subscritor</h3>
<div class="fragment"><div class="line">fprintf(stdout, <span class="stringliteral">&quot;%s\n&quot;</span>, message);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md20"></a>
Listagem de caixas</h3>
<p>Cada linha da listagem de caixas deve ser impressa da seguinte forma:</p>
<div class="fragment"><div class="line">fprintf(stdout, <span class="stringliteral">&quot;%s %zu %zu %zu\n&quot;</span>, box_name, box_size, n_publishers, n_subscribers);</div>
</div><!-- fragment --><p>As caixas devem estar ordenadas por ordem alfabética, não sendo garantido que o servidor as envie por essa ordem (i.e., o cliente deve ordenar as caixas antes das imprimir).</p>
<h2><a class="anchor" id="autotoc_md21"></a>
3.5 Espera Ativa</h2>
<p>No projeto, nunca devem ser usados mecanismos de espera ativa.</p>
<h1><a class="anchor" id="autotoc_md22"></a>
4. Sugestão de implementação</h1>
<p>Sugere-se que implementem o projeto através dos seguintes passos:</p>
<ol type="1">
<li>Implementar as interfaces de linha de comando (CLI) dos clientes;</li>
<li>Implementar a serialização do protocolo de comunicação;</li>
<li>Implementar uma versão básica do <code>mbroker</code>, onde só existe uma <em>thread</em> que, em ciclo, a) recebe um pedido de registo; b) trata a sessão correspondente; e c) volta a ficar à espera do pedido de registo;</li>
<li>Implementar a fila produtor-consumidor;</li>
<li>Utilizar a fila produtor-consumidor para gerir e encaminhar os pedidos de registo para as <em>worker threads</em>.</li>
</ol>
<h1><a class="anchor" id="autotoc_md23"></a>
5. Submissão e avaliação</h1>
<p>A submissão é feita através do Fénix <b>até sexta-feira, dia 13/Janeiro/2023, às 20h00</b>.</p>
<p>Os estudantes devem submeter um ficheiro no formato <code>zip</code> com o código fonte e o ficheiro <code>Makefile</code>. O arquivo submetido não deve incluir outros ficheiros (tais como binários). Além disso, o comando <code>make clean</code> deve limpar todos os ficheiros resultantes da compilação do projeto, bem como o comando <code>make fmt</code>, para formatar automaticamente o código.</p>
<p>Recomendamos que os alunos se assegurem que o projeto compila/corre corretamente no <a href="https://github.com/tecnico-so/lab_ambiente">ambiente de referência</a>. Ao avaliar os projetos submetidos, em caso de dúvida sobre o funcionamento do código submetido, os docentes usarão o ambiente de referência para fazer a validação final. O uso de outros ambientes para o desenvolvimento/teste do projeto (e.g., macOS, Windows/WSL) é permitido, mas o corpo docente não dará apoio técnico a dúvidas relacionadas especificamente com esses ambientes.</p>
<p>A avaliação será feita de acordo com o método de avaliação descrito no Fénix</p>
<p><em>Bom trabalho!</em> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
